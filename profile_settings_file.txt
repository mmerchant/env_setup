# Set VI operating mode for terminal
set -o vi

export HOMEBREW_GITHUB_API_TOKEN=''

export PGHOST=/tmp

# Set unlimited history
export HISTSIZE=""

# Don't put duplicate lines or lines starting with space in the history.
export HISTCONTROL=ignoreboth

# Append to history, don't overwrite it
shopt -s histappend

set_prompt()
{
    local last_cmd=$?
    local txtreset='$(tput sgr0)'
    local txtbold='$(tput bold)'
    local txtblack='$(tput setaf 0)'
    local txtred='$(tput setaf 1)'
    local txtgreen='$(tput setaf 2)'
    local txtyellow='$(tput setaf 3)'
    local txtblue='$(tput setaf 4)'
    local txtpurple='$(tput setaf 5)'
    local txtcyan='$(tput setaf 6)'
    local txtwhite='$(tput setaf 7)'
    # unicode "✗"
    local fancyx='\342\234\227'
    # unicode "✓"
    local checkmark='\342\234\223'
    # Line 1:user@host [Date Time]
    # Line 2: Line number
    PS1="\n\[\033[01;31m\]\u@\h\[\033[01;36m\] [\d \@] \[\033[01;33m\] \w"
    PS1+="\n\[\033[00m\]<\#>:"
    #PS1="\[$txtbold\]\n\D{%A %d %B %Y %H:%M:%S}\n\[$txtgreen\]\w\n"
    # User color: red for root, yellow for others
    if [[ $EUID == 0 ]]; then
        PS1+="\[$txtred\]"
    else
        PS1+="\[$txtyellow\]"
    fi
    # Line 4: a red "✗" or a green "✓" and the error number
    if [[ $last_cmd == 0 ]]; then
        PS1+="\[$txtgreen\]$checkmark"
    else
        PS1+="\[$txtred\]$fancyx ($last_cmd)"
    fi
    # Line 4: green git branch
    PS1+="\[$txtgreen\]$(__git_ps1 ' (%s)')"
    # Line 4: good old prompt, $ for user, # for root
    PS1+=" \[\033[0m\]\\$ "
    # git-bash-prompt from homebrew might replace this madness
}

PROMPT_COMMAND='set_prompt'

# Get Redshift host, username and password.
if [ -f $HOME/.pgpass ]
then
    rs_host=`cat $HOME/.pgpass | grep -m 1 -i "flowroute.cekzffdqrcts.us-west-2.redshift.amazonaws.com.*$USER" | tail -1 | cut -d : -f 1`
    rs_user=`cat $HOME/.pgpass | grep -m 1 -i "flowroute.cekzffdqrcts.us-west-2.redshift.amazonaws.com.*$USER" | tail -1 | cut -d : -f 4`
    rs_pass=`cat $HOME/.pgpass | grep -m 1 -i "flowroute.cekzffdqrcts.us-west-2.redshift.amazonaws.com.*$USER" | tail -1 | cut -d : -f 5`
    export REDSHIFT_CONNECTION_STRING="user=$rs_user password=$rs_pass host=$rs_host port=5439 dbname=dev"
fi

# PIP Stuff
export PIP_ACCESS_KEY=
export PIP_SECRET_KEY=

# Path
export PATH=/usr/include/i386:/usr/local/bin:/usr/local/sbin:/usr/local/opt/ruby/bin:$PATH

# Frick alias (the magical interpreter
alias frick='$(thefuck $(fc -ln -1))'
alias FRICK='frick'

# Lazy git alias
alias gitit='git pull --rebase'

# iPython notebook starter alias
alias pynb="ipython notebook --notebook-dir='$HOME/Dropbox (Personal)/_scripts/_iPython_Notebooks'"

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
    # We have color support; assume it's compliant with Ecma-48
    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
    # a case would tend to support setf rather than setaf.)
    color_prompt=yes
    else
    color_prompt=
    fi
fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
else
    alias ls='ls -G'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Flootty aliases
alias floome='flootty --url https://floobits.com/<project> --create <terminal_name>'

# Git author
alias mgit='git commit --author "MohammedAli Merchant <m@example.co>"'

# autoenv helper (https://autovenv.readthedocs.org/en/latest/)
source `which autovenv.sh`

# Docker is too long..
alias dm='docker-machine'
alias dml='docker-machine ls'
docker_attach() {
    if [ ! -z "$1" ]; then
        docker exec -i -t $1 bash
    else
        echo "Provide a valid container ID"
        docker ps -a
    fi
}
alias dockls='docker ps -a'
docker_env() {
    if [ ! -z "$1" ]; then
        eval $(docker-machine env $1)
    else
        echo "Provide a valid docker machine"
        docker-machine ls
    fi
}

# Enable AWScli auto complete
complete -C aws_completer aws

# Auto extract..aka don't worry about it
extract() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)     echo "'$1' cannot be extracted via extract()" ;;
esac
     else
         echo "'$1' is not a valid file."
     fi
 }

 # Sort by size
 sbs() {
     du -d 1 | sort -nr | perl -pe 's{([0-9]+)}{sprintf "%.1f%s", $1>=2**30? ($1/2**30, "G"): $1>=2**20? ($1/2**20, "M"): $1>=2**10? ($1/2**10, "K"): ($1, "")}e';
 }

 if [ -f $(brew --prefix)/etc/bash_completion ]; then
     . $(brew --prefix)/etc/bash_completion
 fi

# Output man pages in postscript and open them in preview (thanks pwilson)
pman() {
    man -t $1 | open -f -a Preview
}
m2() {
    open -a "Marked 2" $1
}

